---
layout: stickie
title: Playing with arel
meta: Arel, ruby
---
<h3>users table stuff</h3>

<p>
I like to use an 'arex' helper method to wrap arbitrary active record queries...
</p>
<pre>
  def arex query
    ActiveRecord::Base.connection.execute query
  end

  users = Arel::Table.new(:user)
  basic_query = users.project(Arel.sql(sql('*'))) # select all fields
  basic_query = users.project(users[:id]) # select one field
</pre>
<p>
specify fields
</p>
<pre>
  specific_query = users.project([users[:id], users[:username]])
</pre>
<p>
... with conditions
</p>
<pre>
  specific_query = users.project([users[:id], users[:username]]).where(users[:id].eq(1))
</pre>

<p>... with a join, can get tricky</p>
<pre>
  join_query = users.project([users[:id], users[:username]]).join(:user_profile).on(users[:id].eq('user_profile.user_id'))
</pre>
<p>
Returns ...
</p>
<pre>
  "SELECT \"user\".\"id\", \"user\".\"username\" FROM \"user\" INNER JOIN 'user_profile' ON \"user\".\"id\" = 0"
</pre>
<p>
using additional Arel tables seems to clear this up
</p>
<pre>
  profiles = Arel::Table.new(:user_profile)

  join_query = users.project([users[:id], users[:username]]).join(profiles).on(users[:id].eq(profiles['user_id']))
</pre>
<p>
and you can relax it a bit too
</p>
<pre>
  join_query = users.project('*').join(profiles).on(users[:id].eq(profiles['user_id']))
</pre>
<h2>get a relation's columns</h2>
<pre>
  users.columns.map(&:name)
</pre>

<h2>Updating tables</h2>
<pre>
  crudder = Arel::SelectManager.new users.engine

  crudder.compile_update([[users[:username], "steveo@lyti.cs"]]).where(users[:id].eq(1)).to_sql
  #=> "UPDATE \"user\" SET \"username\" = 'steveo@lyti.cs' WHERE \"user\".\"id\" = 1"

  profiles = Arel::Table.new(:user_profile)
  user_groups = Arel::Table.new(:user_group)
</pre>

<h2>Get lender profiles</h2>
<pre>
  profiles.project(Arel.star).join(user_groups).on(user_groups[:user_id].eq(profiles[:user_id])).where(user_groups[:group_id].eq(3))

  manager = Arel::SelectManager.new Table.engine
</pre>
<h2>Soo ... stored procedures :D</h2>

<h2>Could you express the following as Arel... ?</h2>
<pre>
  ActiveRecord::Base.connection.execute "select id, (select * from my_schema.account_ref(u.id)) as bal from user as u where u.id = 109"
</pre>
<p>
And the answer, as it turns out, is yes, somewhat ...
</p>
<pre>
  users = Arel::Table.new(:user)
  users.table_alias = 'u'

  manager = Arel::SelectManager.new users.engine
            manager.project Arel.star
            manager.from Arel.sql("my_schema.account_ref(#{users.table_alias}.id)")
            # as = manager.as(Arel.sql('bal'))
</pre>
<p>
In sql you have column aliases (AS) and table (or *relation*) aliases (table_alias)
</p>
<pre>
  users.project([users[:id], manager.as('bal')])#.from('u')#.as(Arel.sql('u'))
  arex users.project([users[:id], manager.as('bal')]).where(users[:id].eq(109)).to_sql
</pre>
<p>
sadly this is considerably more verbose than just using connection.execute with esql
</p>
<pre>
  accounts = Arel::Table.new("financial.account")
</pre>
<p>
Some failed experiements ....
the answer turned out to be: users.table_alias = 'u', see above

          # try to create an alias of u for user
          # users_manager = Arel::SelectManager.new users.engine
          # users_manager.from(users)#.as('u')
          # users_as = users_manager.as(Arel.sql('u'))
          # users_manager.project([users[:id], manager.as('bal')]).as('u').where(users[:id].eq(109)).to_sql

          # user_manager = Arel::SelectManager.new Table.engine
          # manager.project Arel.sql('id', as])
          # manager.from as
          # manager.to_sql.must_be_like "SELECT name FROM (SELECT * FROM zomg) foo"
          </p>

          <p>
The top level Arel classes
</p>
<pre>
Arel::AliasPredication  Arel::Attribute         Arel::Attributes
Arel::Compatibility  Arel::Crud
Arel::DeleteManager
Arel::Expression   Arel::Expressions
Arel::InnerJoin      Arel::InsertManager
Arel::Math
Arel::Node   Arel::Nodes
Arel::OrderPredications  Arel::OuterJoin
Arel::Predications
Arel::Relation
Arel::SelectManager  Arel::Sql            Arel::SqlLiteral
Arel::Table        Arel::TreeManager
Arel::UpdateManager
Arel::VERSION   Arel::Visitors
</pre>

<h2>Using arel for data analysis</h2>

<p>
The nice thing about active record is that it works for mvc really well
But if you want to do data analysis, such as working out the function of some data, it's not so good
</p>
<p>
So if we want to analyse bidding data:
</p>
<pre>
  bids = Arel::Table.new(Bid.table_name)
  res = arex bids.project(bids[:id]).where(bids[:id].eq(1)).to_sql
</pre>
<p>
How many bids placed by day of the week
</p>
<pre>
  res = arex bids.project(bids[:id].count).group("extract(dow from #{bids.name}.created_at)").to_sql
</pre>
<p>
... or day of the year
</p>
<pre>
  res = arex bids.project(bids[:id].count).group("extract(doy from #{bids.name}.created_at)").to_sql
</pre>
<p>
add in the date as a field, and get the number per month since launch
</p>
<pre>
  res = arex bids.project(bids[:id].count, "date_trunc('month', #{bids.name}.created_at) as gdate").group("gdate").to_sql
</pre>
<p>
get the number per day ...
</p>
<pre>
  res = arex bids.project(bids[:id].count, "date_trunc('day', #{bids.name}.created_at) as group_date").group("group_date").to_sql
</pre>
<p>
add in the status of the bid ...
</p>
<pre>
  res = arex bids.project(bids[:id].count, "date_trunc('day', #{bids.name}.created_at) as group_date", bids[:status]).group("group_date", bids[:status]).to_sql
</pre>

